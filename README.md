[BGPM_Project_Document.pdf](https://github.com/user-attachments/files/18070219/BGPM_Project_Document.pdf)

Computer Networks BGP Measurements Project 
1
<p>Georgia Tech master degree cs6250 Network Project by Victor Kim</p><p>11/21/2024-11/28/2024</p><p><br /></p><p><a href="https://drive.google.com/drive/u/0/folders/1E0LAAoxzR8k5h0RwQu7z5kb5MQ_2xJgE">https://drive.google.com/drive/u/0/folders/1E0LAAoxzR8k5h0RwQu7z5kb5MQ_2xJgE</a>&nbsp;</p><p>Project Overview and Background</p><p>The zip file accompanying this assignment contains the code and data needed to implement the</p><p>functions in the file bgpm.py. You will submit only bgpm.py to Gradescope and all your code for the project must be contained within bgpm.py.</p><p>This project description, in combination with the comments in bgpm.py, comprise the complete requirements for the project. There are two complete sets of data included in the zip file and the provided test harness in check_solution.py will test each of your functions against both sets of data. You are welcome to copy and modify check_solution.py to better suit your development and debugging workflow, but you will have the best chance of success with the hidden data set used for grading if your final submission passes all the tests in the unmodified check_solution.py.</p><p>This project is designed to work in the class VM where the BGPStream libraries are installed. Your code will need to run without modification in the course VM.</p><p><br /></p><p>Setup</p><p>Use Linux command installing BGPStream and PyBGP</p><p><br /></p><p>Task 1. Understanding BGP Routing table Growth</p><p>In this task you will measure the growth over time of Autonomous Systems and advertised prefixes. The growth of unique prefixes contributes to ever-growing routing tables handled by routers in the Internet core. As optional background reading, please read the seminal paper On Characterizing BGP Routing Table Growth.</p><p>Task 1A: Unique Advertised Prefixes Over Time</p><p>This task will use cache files from the rib_files subdirectories. These are RIB files, so you will pass “rib-file" in your call to set_data_interface_option(). Using the data from cache files, measure the number of unique advertised prefixes over time. Each file is an annual snapshot. Calculate the number of unique prefixes within each snapshot by completing the function unique_prefixes_by_snapshot(). Make sure that your function returns the data structure exactly as specified in bgpm.py.</p><p>Task 1B: Unique Autonomous Systems Over Time</p><p>This task will use cache files from the rib_files subdirectories. These are RIB files, so you will pass “rib-file" in your call to set_data_interface_option(). Using the data from the cache files, measure the number of unique Autonomous Systems over time. Each file is an annual snapshot. Calculate the number of unique ASes within each snapshot by completing the function unique_ases_by_snapshot(). Make sure that your function returns the data structure exactly as specified in bgpm.py.</p><p>Note: Consider all paths in each snapshot. Here, we consider all AS that appear in the paths (not only the origin AS). You may encounter corner cases of paths with the following form: “25152 2914 18687 {7829,14265}”. In this case, consider the AS in the brackets as a single AS. So, in this example, you will count 4 distinct ASes.</p><p><br /></p><p>Task 1C: Top-10 Origin AS by Prefix Growth</p><p>This task will use cache files from the rib_files subdirectories. These are RIB files, so you will pass “rib-file" in your call to set_data_interface_option(). Using the data from the cache files, calculate the percentage growth in advertised prefixes for each AS over the entire timespan represented by the snapshots by completing the function top_10_ases_by_prefix_growth(). Make sure that your function returns the data structure exactly as specified in bgpm.py.</p><p>Consider each origin AS separately and measure the growth of the total unique prefixes advertised by that AS over time. To compute this, for each origin AS:</p><p>1. Identify the first and the last snapshot where the origin AS appeared in the dataset.</p><p>2. Calculate the percentage increase of the advertised prefixes, using the first and the last snapshots.</p><p>3. Report the top 10 origin AS sorted smallest to largest according to this metric. In the event of a tie (i.e., the same percentage increase), the AS with the lower number should come first.</p><p>Corner case: When calculating the prefixes originating from an origin AS, you may encounter paths of the following form: “25152 2914 18687 {7829,14265}”. This is a corner case, and it should affect only a small number of prefixes. In this case, you consider the entire set of AS “{7829,14265}” as the origin AS.</p><p>Task 2: Routing Table Growth: AS-Path Length Evolution Over Time</p><p>In this task you will measure if an AS is reachable over longer or shorter path lengths as time progresses. Towards this goal you will measure the AS path lengths, and how they evolve over time.</p><p>This task will use cache files from the rib_files subdirectories. These are RIB files, so you will pass “rib-file" in your call to set_data_interface_option(). Using the data from the cache files, calculate the shortest path for each origin AS in each snapshot by completing the function</p><p><br /></p><p>shortest_path_by_origin_by_snapshot(). Make sure that your function returns the data structure exactly as specified in bgpm.py.</p><p>For each snapshot, you will compute the shortest AS path length for each origin AS in the snapshot by following the steps below:</p><p>- Identify each origin AS present in the snapshot. For example, given the path “11666 3356 3786”, “3786” is the origin AS.</p><p>- For each origin AS, identify all the paths for which it appears as the origin AS.</p><p>- Compute the length of each path by considering each AS in the path only once. In other words, you want to remove the duplicate entries for the same AS in the same path and count the total number of unique AS in the path.</p><p>- Example: Given the path “25152 2914 3786 2914 18313”, ”18313” is the origin AS and ”2914” appears twice in the path. This is a path of length 4.</p><p>- Among all the paths for an AS within the snapshot, compute the shortest path length.</p><p>- Filter out all paths of length 1.</p><p>- Corner cases: The data that we are working with are real data, which means that there may be few corner cases. In the vast majority of cases, paths have a straightforward form of “25152 2914 3786”, but you might encounter corner cases such as:</p><p>a. If an AS path has a single unique AS or a single repeated AS (e.g., “25152 25152 25152”), the path has length 1 and should be ignored</p><p>b. An AS path entry that looks like “{2914,14265}” is an aggregate or AS_SET and constitutes a single AS path entry. It does not need to be parsed in any way. You can read more about aggregation in RFC 4271. Example: The length of the AS path “25152 2914 18687 {2914,14265} 2945 18699” is 6. Example: The length of the AS path “25152 2914 18687 18687 {18687}” is 4. The entries “18687” and “{18687}” are distinct, so you only de-duplicate “18687”.</p><p>c. You can ignore all other corner cases.</p><p><br /></p><p>Task 3: Announcement-Withdrawal Event Durations</p><p>In this task, we will measure how long prefix Announcements last before they are withdrawn. This matters because, when a prefix gets Advertised and then Withdrawn, this information propagates and affects the volume of the associated BGP traffic. Optional background reading on this topic can be found in The Shape of a BGP Update.</p><p>This task will use cache files from the update_files subdirectories. These are update files, so you will pass “upd-file" in your call to set_data_interface_option(). Using the data from the cache files, we will measure how long prefix Announcements last before they are withdrawn by completing the function aw_event_durations(). Make sure that your function returns the data structure exactly as specified in bgpm.py.</p><p>In defining Announcement Withdrawal (AW) events, we will only consider explicit withdrawals. An explicit withdrawal occurs when a prefix is advertised with an (A)nnouncement and is then (W)ithdrawn. In contrast, an implicit withdrawal occurs when a prefix is advertised (A) and then re-advertised (A) - usually with different BGP attributes.</p><p>To compute the duration of an Explicit AW event for a given peerIP/prefix, you will need to monitor the stream of (A)nnouncements and (W)ithdrawals separately per peerIP/prefix pair.</p><p>- Example: Given the stream: A1 A2 A3 W1 W2 W3 W4 for a specific peerIP/prefix pair, you have an implicit withdrawal A1-A2, another implicit withdrawal A2-A3, and, finally, an explicit withdrawal (and AW event) A3-W1. W1-W2, W2-W3, and W3-W4 are all meaningless, as there’s no active advertisement. The duration of the AW event is the time difference between A3 and W1. Again, we are only looking for last A and first W.</p><p>- Example: Given the stream: A1 A2 A3 W1 W2 W3 W4 A4 A5 W4 for a specific peerIP/prefix pair, we have two AW events at A3-W1 and A5-W4.</p><p>- We consider only non-zero AW durations.</p><p><br /></p><p>Task 4: RTBH Event Durations</p><p>In this task you will identify and measure the duration of Real-Time Blackholing (RTBH) events.</p><p>You will need to become familiar with Blackholing events. Good resources for this include RFC 7999, Section 2, BGP communities: A weapon for the Internet (Part 2), and the video Nokia - SROS: RTBH - Blackhole Community.</p><p>This task will use cache files from the update_files_blackholing subdirectories. These are update files, so you will pass “upd-file" in your call to set_data_interface_option(). Using the data from the cache files, we will identify events where prefixes are tagged with a Remote Triggered Blackholing (RTBH) community and measure the time duration of the RTBH events by completing the function rtbh_event_durations(). Make sure that your function returns the data structure exactly as specified in bgpm.py.</p><p>The duration of an RTBH event for a given peerIP/prefix pair is the time elapsed between the last (A)nnouncement of the peerIP/prefix that is tagged with an RTBH community value and the first (W)ithdrawal of the peerIP/prefix. In other words, we are looking at the stream of Announcements and Withdrawals for a given peerIP/prefix and identifying only explicit withdrawals for an RTBH tagged peerIP/prefix.</p><p>To identify and compute the duration of an RTBH event for a given peerIP/prefix, you will need to monitor the stream of (A)nnouncements and (W)ithdrawals separately per peerIP/prefix pair.</p><p>- Example: Given the stream: A1 A2 A3(RTBH) A4(RTBH) W1 W2 W3 W4 for a specific peerIP/prefix pair, A4(RTBH)-W1 denotes an RTBH event and the duration is calculated by taking the time difference between A4(RTBH) and W1.</p><p>- Note: There can be more than one RTBH event in a given stream. For example, in the stream A1 A2 A3(RTBH) A4(RTBH) W1 W2 W3 W4 A5(RTBH) W5, there are two RTBH events: A4(RTBH)-W1 and A5(RTBH)-W5.</p><p><br /></p><p><br /></p><p><br /></p>
글 설정
라벨
일치하는 추천 없음
게시 날짜
24. 11. 29. 오후 7:12
퍼머링크
위치
옵션
글: 수정추가 글을 로드했습니다.
